Пояснювальна запискадо дипломного проєктуна тему: Веб-сервіс для аналізу відгуків на мобільні застосункиКПІ.ІП-9618.045440.02.81Київ – 2023ЗМІСТ1	ВСТУП1	АНАЛІЗ ВИМОГ ДО ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ	51.1	Загальні положення	51.2	Змістовний опис і аналіз предметної області	61.3	Аналіз існуючих технологій та успішних IT-проєктів	81.3.1	Аналіз відомих алгоритмічних та технічних рішень	81.3.2	Аналіз допоміжних програмних засобів та засобів розробки	101.3.3	Аналіз відомих програмних продуктів	121.4	Аналіз вимог до програмного забезпечення	161.4.1	Розроблення функціональних вимог	271.4.2	Розроблення нефункціональних вимог	371.5	Постановка задачі	39Висновки до розділу	402	МОДЕЛЮВАННЯ ТА КОНСТРУЮВАННЯ ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ	422.1	Моделювання та аналіз програмного забезпечення	422.2	Архітектура програмного забезпечення	442.2.1	Архітектурний патерн	452.2.2	Деталізація компонентів	482.3	Конструювання програмного забезпечення	502.3.1	Оригінальні реалізації	502.4	Аналіз безпеки даних	58Висновки до розділу	603	АНАЛІЗ ЯКОСТІ ТА ТЕСТУВАННЯ ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ	623.1	Аналіз якості ПЗ	623.1.1	Аналіз відповідності нефункціональним вимогам	623.1.2	Метрики якості коду	653.2	Опис процесів тестування	743.3	Опис контрольного прикладу	86Висновки до розділу	934	ВПРОВАДЖЕННЯ ТА СУПРОВІД ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ	954.1	Розгортання програмного забезпечення	954.2	Підтримка програмного забезпечення	98Висновки до розділу	98ВИСНОВКИ	99СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ	100ДОДАТКИ	101 ПЕРЕЛІК УМОВНИХ ПОЗНАЧЕНЬIDE	–	Integrated Development Environment – інтегроване середовище розробки.NLP	–	Natural language processing.ETL	–	Extract, Transform, LoadСентимент	 –	Настрій.N-gram	–	Послідовність з n слів у текстовому або мовному датасеті.MVT	–	Model-View-Template 1	ВСТУПЗ урахуванням швидкого розвитку технологій, аналіз даних стає все важливішим для компаній. Особливо важливим є аналіз відгуків користувачів, що допомагає виявити проблеми, знайти нові можливості та підтримувати репутацію. Автоматизований аналіз відгуків стає незамінним інструментом, оскільки надходить велика кількість відгуків щодня. На ринку існує багато інструментів для аналізу відгуків, але вони мають обмеження.Ця дипломна робота присвячена розробці гнучкого веб-додатка для аналізу відгуків та рейтингів додатків. Результати цієї роботи можуть бути застосовані в бізнесі для прийняття обґрунтованих рішень. Робота розкриває актуальність аналізу відгуків та сентименту, особливо в контексті мобільних додатків, і пропонує нові можливості для автоматизованого аналізу даних. Виклики, що виникають у розробників додатків, потребують нових та ефективних інструментів, і ця робота відповідає на ці виклики. Розроблений веб-додаток є внеском у розвиток цієї галузі. 1	АНАЛІЗ ВИМОГ ДО ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ1.1	Загальні положенняАналіз відгуків користувачів є невід'ємною частиною діяльності розробників додатків та інших компаній, які пропонують продукти або послуги. Відгуки надають важливу інформацію про досвід користувачів, можливі проблеми, а також виграшні властивості продукту. У світлі великої кількості відгуків та швидкості їх надходження, автоматизовані інструменти для аналізу відгуків стали не тільки практичними, але й необхідними [1, 2].Сучасний агрегатори-аналізатори відгуків зазвичай включають такі елементи, як аналіз сентименту, тематичне моделювання та візуалізація даних. Аналіз сентименту дозволяє визначити емоційний відтінок відгука (позитивний, негативний, нейтральний), в той час як тематичне моделювання допомагає виявити ключові теми та питання, які порушуються в відгуках. Візуалізація даних, у свою чергу, дозволяє подати ці складні датасети в легко зрозумілій формі, що сприяє кращому розумінню та прийняттю рішень [3, 4].Програмне забезпечення (агрегатори) для аналізу відгуків має важливе значення в багатьох сферах, включаючи електронну комерцію, розваги, технології та соціальні медіа. Для розробників додатків можливість швидко та ефективно аналізувати відгуки користувачів може мати значний вплив на успіх або невдачу їх продуктів [5].Під час розробки програмного забезпечення для аналізу відгуків важливо враховувати ряд вимог, таких як зручність використання, гнучкість, масштабованість та можливість персоналізації. Ці вимоги визначають, наскільки ефективно програмне забезпечення може відповідати на потреби своїх користувачів [6].Враховуючи цю інформацію, програмне забезпечення для аналізу та моніторингу відгуків на мобільні застосунки, яке розробляється в рамках цієї дипломної роботи, було надихнуте визнаними агрегаторами та аналізаторами відгуків. В цілому, це має бути високоякісний продукт, який надасть користувачам потужні інструменти для збору, аналізу та візуалізації відгуків з AppStore та GooglePlay, щоб допомогти розробникам додатків краще розуміти своїх користувачів, їхні думки та відчуття, а також допомогти їм у вдосконаленні своїх продуктів на основі цієї інформації.1.2	Змістовний опис і аналіз предметної областіВ сучасному світі з високим рівнем конкуренції в сфері програмного забезпечення, важливість ефективного аналізу відгуків користувачів важко переоцінити. Вони не тільки надають об'єктивний погляд на сильні та слабкі сторони продукту, але й мають безпосередній вплив на рішення потенційних користувачів про встановлення або придбання додатка.На сьогоднішній день на ринку існує багато веб-сервісів, які агрегують та аналізують відгуки з різних платформ, зокрема таких як Google Play та App Store. Однак, їх функціональність часто обмежується базовими показниками, такими як загальний рейтинг, кількість відгуків, та не завжди включає детальний аналіз самого тексту відгуку. Крім того, часто вони не використовують належним чином передові технології, такі як обробка природної мови (NLP) та машинне навчання, що обмежує їх здатність до глибокого аналізу відгуків та виявлення у них складних шаблонів.Деякі сучасні платформи для агрегації та аналізу відгуків схильні до використання простіших, але менш точних методів, ніж передові техніки обробки природної мови (NLP) та машинне навчання. Зокрема, вони можуть обмежуватися простим підрахунком кількості позитивних та негативних відгуків, без виявлення тонкої емоційної забарвленості або пошуку глибоких шаблонів у відгуках.Ці платформи часто використовують базові техніки обробки тексту, такі як "мішок слів" (bag of words), де текст аналізується як ненормоване множину слів, без урахування їх порядку або контексту. Хоча цей метод може бути корисним для знаходження найпоширеніших слів у відгуках, він має серйозні обмеження, оскільки не може виявляти більш складні мовні структури або зміст.Крім того, вони можуть використовувати простий сентимент-аналіз, базуючись на списку позитивних та негативних слів. Цей метод, хоча й може давати загальне уявлення про позитивне чи негативне забарвлення відгуку, часто не враховує складні мовні нюанси, іронію або контекст, який може змінювати значення слова.Така обмежена функціональність може призвести до помилкових висновків про товари або послуги, оскільки відгуки мають велику вагу в процесі прийняття рішень споживачами. Це підкреслює важливість використання більш передових технік, таких як NLP та машинне навчання, для глибокого аналізу відгуків.Існуючі сервіси-агрегатори відгуків часто пропонують стандартний набір функцій та інструментів для аналізу відгуків, який не завжди може задовольнити індивідуальні потреби конкретного користувача. Хоча деякі з них дозволяють користувачам налаштувати деякі параметри аналізу, такі як вибір рейтингу для відображення відгуків, вони зазвичай не надають повного контролю над процесом аналізу або недостатньо гнучких інструментів для візуалізації результатів.Це підкреслює потребу в більшій персоналізації сервісів агрегації відгуків. Ідеальна система повинна давати користувачам можливість налаштовувати параметри аналізу відповідно до їх конкретних інтересів та потреб, враховуючи такі чинники, як галузь, тип продукту або сервісу, географічне розташування та інші.Що стосується дипломного проекту, на поточному етапі розробки основна увага приділяється побудові робустної та надійної бази системи, яка зможе ефективно збирати, агрегувати та аналізувати відгуки з різних платформ. Проте, на наступному етапі розробки планується розширити функціональність системи, включаючи більш глибокі можливості персоналізації. Метою цього розширення є створення системи, яка не лише забезпечує всебічний аналіз відгуків, але й може бути точно налаштована для задоволення індивідуальних потреб користувача.Тому цей дипломний проект пропонує розробку інформаційної системи, яка включатиме передові технології NLP та машинного навчання для аналізу тексту відгуків. Це дасть можливість не тільки кількісно, але й якісно аналізувати відгуки, включаючи сентимент-аналіз, що дозволяє визначити емоційне забарвлення відгуку.Крім того, система надасть гнучкі інструменти для візуалізації результатів аналізу, дозволивши користувачам краще розуміти шаблони та тренди, які виходять з відгуків. Система також буде використовувати методи веб-скрейпінгу для збору даних з різних платформ застосунків у режимі реального часу, що забезпечить актуальність даних.1.3	Аналіз існуючих технологій та успішних IT-проєктівПроаналізуємо відоме на сьогодні алгоритмічне забезпечення у даній області та технічні рішення, що допоможуть у реалізації веб-додатка для аналізу відгуків клієнтів на мобільні застосунки. Далі будуть розглянуті допоміжні програмні засоби, засоби розробки та готові програмні рішення.1.3.1	Аналіз відомих алгоритмічних та технічних рішеньСеред основних алгоритмічних рішень, які використовуються для аналізу зворотного зв’язку, є алгоритми обробки природної мови (NLP). Вони спрямовані на розуміння, інтерпретацію та маніпулювання людською мовою.Збір відгуків: тут використовуються алгоритми веб-скрейпінгу, які автоматизують процес вилучення даних із веб-сайтів і дозволяють швидко збирати велику кількість відгуків із платформ додатків.Обробка даних і завантаження даних: зібрані відгуки повинні бути оброблені та завантажені в базу даних. Тут можна використовувати алгоритми ETL (Extract, Transformer, Load).N-грами використовуються для вивчення контексту в тексті, і це один з ключових алгоритмів НЛП. N-грами дозволяють моделі розглядати групи з n слів, що підвищує точність визначення контексту. Використання N-грам в моделі засноване на можливості розгляду груп з n послідовних слів.Очищення тексту перед аналізом: передусім, текст має бути попередньо оброблений. У цьому випадку це може включати видалення стоп-слів (наприклад, "і", і" але), лематизацію (скорочення слів до їх основної форми), видаленнястоп-слів (наприклад, "і", "і", "але"), видалення знаків пунктуації та цифр тощо.Алгоритми НЛП використовуються для фактичного аналізу відгуків, включаючи, наприклад, модель машинного навчання, яка була навчена визначати емоційне забарвлення тексту.Також, було розглянуто декілька потенційних архітектур для розробки цього проекту. Спочатку, мікросервісна архітектура привернула увагу своєю гнучкістю і масштабованістю. Ця архітектура орієнтована на створення незалежних служб, які виконують конкретні задачі і можуть розроблятися та розгортатися незалежно одна від одної. Однак, це також може вносити додаткову складність в управління проектом і підтримку, особливо в маленьких командах.Далі було взято до уваги монолітну архітектуру. Вона пропонує єдиний, недільний код для всієї програми. Це може спростити розробку і підтримку, але має свої власні недоліки, такі як відсутність гнучкості та складності масштабування.Сервіс-орієнтована архітектура (SOA) також була взята до уваги. Ця архітектура дозволяє створювати модульні служби, які можуть бути повторно використані в межах системи. Однак, SOA може вносити додаткову складність при розробці та підтримці, особливо при великому обсязі даних і високих вимогах до продуктивності.Враховуючи ці фактори, вирішено було використати багатошарову клієнт-серверну архітектуру для розробки проекту. Ця архітектура вибрана через її відносну простоту і зручність у розробці та підтримці. Вона дозволяє розробникам фокусуватися на важливих аспектах проекту, надаючи достатню гнучкість для розробки фронтенду і бекенду незалежно одне від одного.Ще вибору сприяло і те, що майбутнє розширення проекту може бути здійснене за допомогою додавання додаткових серверів, що забезпечує гнучкість та масштабованість на відміну від монолітної архітектури. Крім того, використання цієї архітектури полегшує інтеграцію з іншими веб-службами і технологіями, що є важливим аспектом в розробці цього проекту.1.3.2	Аналіз допоміжних програмних засобів та засобів розробкиПри виборі технологій для розробки програмного забезпечення було проведено порівняльний аналіз різних мов програмування та інтегрованих середовищ розробки (IDE).Мова програмування. Python було обрано через його гнучкість, велику підтримку спільноти, а також широкий спектр бібліотек для обробки природної мови і машинного навчання. Хоча існують інші мови, як-от R та Java, які теж широко використовуються в аналізі даних та NLP, Python має більш стрімкий кривий навчання та гнучкість для різних задач. JavaScript було вибрано для фронтенду, особливо через використання бібліотеки React.Інтегровані середовища розробки (IDE). PyCharm було вибрано як основне IDE для Python. PyCharm від JetBrains надає багатий набір функцій для розробки Python, включаючи інтелектуальне кодування, глибоку навігацію по коду, швидку фіксацію помилок та рефакторинг. Хоча існують інші IDE, як-от Jupyter Notebook або Visual Studio Code, PyCharm має більш спеціалізовані інструменти для Python. Datagrip, також від JetBrains, було обрано для роботи з базами даних. В порівнянні з іншими засобами, як-от MySQL Workbench або DBeaver, DataGrip пропонує більш гнучкі та потужні інструменти для роботи з різними базами даних.Щодо веб-фреймворків. Django було вибрано як основний фреймворк для розробки бекенду. Django є високорівневим фреймворком Python, який прискорює розробку веб-додатків, надаючи готові модулі для роботи з базами даних, аутентифікації користувачів, роботи з формами тощо. В порівнянні з іншими Python фреймворками, наприклад Flask або Pyramid, Django надає більше готових рішень "з коробки", що дозволяє зосередитися на специфіці задачі, а не на розробці базової інфраструктури. React було вибрано для розробки клієнтської частини застосунку. React є популярною JavaScript бібліотекою для створення користувацьких інтерфейсів, розробленою Facebook. Вона надає компонентний підхід до створення інтерфейсів, що полегшує розробку і підтримку коду. У порівнянні з іншими JS фреймворками, такими як Angular або Vue.js, React має велику спільноту, велику кількість доступних ресурсів для навчання та гнучкість у виборі додаткових бібліотек і інструментів.Таск-брокери та системи черг. Redis і Celery були обрані для розподілених задач та черг. Redis - це високопродуктивна система зберігання даних в пам'яті, яка використовується як база даних, брокер повідомлень і сервер кешування. В порівнянні з іншими базами даних, наприклад, MySQL або PostgreSQL, Redis дозволяє більш ефективну роботу з великими об'ємами даних в режимі реального часу. Celery - це асинхронна система черг завдань, яка дозволяє виконувати завдання в розподіленому середовищі, поліпшуючи продуктивність і відмовостійкість системи. В порівнянні з іншими системами черг, наприклад, RabbitMQ або Apache Kafka, Celery пропонує гнучкість у виборі брокера завдань та більш просту інтеграцію з Python додатками.Інструменти для машинного навчання. Transformers від Hugging Face були обрані для роботи з преднатренованими моделями для NLP-задач. Ця бібліотека надає широкий спектр моделей для NLP, що включає BERT, GPT-2, RoBERTa та інші, а також утиліти для обробки даних, тренування та оцінювання моделей. В порівнянні з іншими бібліотеками для машинного навчання, наприклад, TensorFlow або PyTorch, Transformers надає більш широкий вибір преднатренованих моделей та спрощує їх використання в різних задачах NLP.Інструменти візуалізації. Plotly - це бібліотека, що надає компоненти React для створення графіків. Вона була вибрана через її інтеграцію з React та здатність створювати різноманітні види графіків. Ця бібліотека є гнучкішою для роботи з React у порівнянні з іншими бібліотеками візуалізації, такими як D3.js або Highcharts.1.3.3	Аналіз відомих програмних продуктівДля порівняння дипломної роботи з аналогом можна скористатись таблицею 1.1.Таблиця 1.1 – Порівняння з аналогомФункціонал/критерій	GetSenti	AppFigures	AppBot	ПоясненняРеєстрація та авторизація користувачів	+	+	+	--Збір відгуків	+	+	+	--Аналіз сентименту	+	+-	+	Appfigures не згадує прямо про аналіз сентименту, але вони мають функціонал, що перетворює відгуки на корисний зворотний зв'язокПерегляд аналітики відгуків	+	-	+	--Управління історією пошуку	+	-	-	--Безкоштовність сервісу	+	-	-	--Орієнтованістьвиключно на мобільні застосунки	+	-	-	Підписки на AppFigures та AppBot включають у себе «зайві» функції для користувача, що зацікавлений лише у аналізі відгуків (напр. аналіз цін та продажів застосунків)Приклади порівнянь з аналогами	Реєстрація та авторизація користувачівРисунок 1.1 – Сторінка реєстрації користувача AppFiguresРисунок 1.2 – Сторінка реєстрації користувача AppBot	Перегляд аналітики відгуківРисунок 1.3 – Демо «Review Analysis» продукту від AppFiguresРисунок 1.4 – Демо «Review Monitoring» продукту від AppBot	Безкоштовність сервісуРисунок 1.5 – «Прайс-ліст» застосунку AppFiguresРисунок 1.5 – «Прайс-ліст» застосунку AppBot1.4	Аналіз вимог до програмного забезпеченняГоловною функцією програмного забезпечення, розробленого в рамках даної дипломної роботи, є забезпечення аналізу відгуків користувачів застосунків на різних платформах з метою допомоги компаніям краще розуміти думки своїх клієнтів. Більше функцій можна побачити на рисунку 1.1.Рисунок 1.1 – Діаграма варіантів використанняВ таблицях 1.2 - 1.13 наведені варіанти використання програмного забезпечення.Таблиця 1.2 - Варіант використання UC-1Use case name	Реєстрація користувачаUse case ID	UC-01Goals	Створити новий обліковий запис користувачаActors	Незареєстрований користувач.Trigger	Користувач обирає "Реєстрація"Pre-conditions	Користувач на сторінці реєстраціїFlow of Events	1)	Користувач вводить email.2)	Користувач вводить пароль.3)	Користувач підтверджує пароль.4)	Система перевіряє дані і створює новий обліковий запис.Extension	Якщо користувач ввів різні паролі, система показує помилку. Якщо пароль занадто слабкий, система показує помилку.Якщо строка не є валідним email, система показує помилку.У разі помилки реєстрація стає неможливоюPost-Condition	Обліковий запис користувача створено, перехід на сторінку входуТаблиця 1.3 - Варіант використання UC-2Use case name	Авторизація користувачаUse case ID	UC-02Goals	Авторизація зареєстрованого користувача в системі.Actors	Зареєстрований користувач.Trigger	Користувач обирає "Вхід".Pre-conditions	Зареєстрований користувач на сторінці авторизації.Flow of Events	1)	Користувач вводить email.2)	Користувач вводить пароль.3)	Система перевіряє введені дані і дозволяє користувачу увійти в разі валідних даних.Extension	Якщо пароль не відповідає збереженому паролю, система показує помилку.Post-Condition	Користувача авторизовано в системі. Тепер користувач має доступ до сервісів.Таблиця 1.4 - Варіант використання UC-3Use case name	Зміна паролюUse case ID	UC-03Goals	Зміна паролю авторизованого користувача.Actors	Авторизований користувач.Trigger	Користувач обирає "Змінити пароль".Pre-conditions	Авторизований користувач у модальному віконці профіля.Flow of Events	1)	Користувач вводить поточний пароль.2)	Користувач вводить новий пароль.3)	Система перевіряє введені дані і змінює пароль користувача.Extension	Якщо поточний пароль неправильний, система показує помилку. Якщо користувач ввів різні нові паролі, система показує помилку.Post-Condition	Пароль користувача змінено. В наступний раз система очікує вводу нового пароля від даного користувачаТаблиця 1.5 - Варіант використання UC-4Use case name	Відновлення паролюUse case ID	UC-04Goals	Відновлення забутого паролю.Actors	Неаутентифікований зареєстрований користувач.Trigger	Користувач обирає "Забули пароль".Pre-conditions	Користувач зареєстрований в системі, але не пам'ятає свій пароль.Flow of Events	1)	Користувач вводить свій email.2)	Система перевіряє email і відправляє на нього лист з посиланням для відновлення паролю.3)	Користувач переходить по посиланню в листі, вводить новий пароль і підтверджує його.4)	Система перевіряє введені дані і змінює пароль користувача.Extension	Якщо користувач ввів різні нові паролі, система показує помилку.Post-Condition	Пароль користувача відновлено. В наступний раз система очікує вводу нового пароля від даного користувачаТаблиця 1.6 - Варіант використання UC-5Use case name	Вихід з системиUse case ID	UC-05Goals	Вихід авторизованого користувача з системи.Actors	Авторизований користувач.Trigger	Користувач обирає "Вийти".Pre-conditions	Авторизований користувач у модальному віконці профіля.Flow of Events	Користувач натискає на кнопку "Вийти" в своєму профілі.Extension	-Post-Condition	Користувач вийшов з системи. Для відновлення доступу необхідна переавторизаціяТаблиця 1.7 - Варіант використання UC-6Use case name	Збір відгуківUse case ID	UC-06Goals	Збір відгуків користувачів про застосунок.Actors	Авторизований користувачTrigger	Система отримує запит від користувача з посиланням на застосунок, якого не існує в базі даних.Pre-conditions	Необхідність отримання нових відгуків на застосунок для подальшого аналізуFlow of Events	Система автоматично збирає відгуки про застосунок за вказаний період (GooglePlay) або на задану кількість (AppStore) використовуючи алгоритми ETL (веб-скрапінг, очищення HTML та трансформування даних застосунку у зручний формат Python словників та подальше завантаження даних у базу)Extension	-Post-Condition	Відгуки зібрані та збережені в системі.Таблиця 1.8 - Варіант використання UC-7Use case name	Аналіз сентиментуUse case ID	UC-07Goals	Аналіз сентименту відгуків про застосунок.Actors	Авторизований користувачTrigger	Система отримує запит від користувача з посиланням на застосунок, якого не існує в базі даних.Pre-conditions	Відгуки зібрані та збережені в системі.Flow of Events	Система автоматично проводить аналіз сентименту шляхом передавання тексту відгуку до NLP моделі та отримання значення cентименту (позитивний, нейтральний, негативний)Extension	-Post-Condition	Результати аналізу сентименту збережені в системі.Таблиця 1.9 - Варіант використання UC-8Use case name	Пошук застосунків у системіUse case ID	UC-08Goals	Пошук застосунку, аналітика якого цікавить користувачаActors	Авторизований користувач.Trigger	Користувач вставляє посилання на застосунок у форму для аналізу.Продовження таблиці 1.9Pre-conditions	Користувач авторизований в системі, дані аналізу застосунку доступні в базі або відгуки на застосунок існують на платформах AppStore чи GooglePlay.Flow of Events	1)	Користувач копіює посилання на застосунок з платформ AppStore чи GooglePlay2)	Користувач вставляє скопійоване щойно посилання у пошукове поле та напискає “Analyze”Extension	Якщо користувач вводить посилання, яке не відповідає формату посилань на застосунки з платформ, або застосунок за таким посиланням не знайнедо, то система інформує користувача про це помилкою.Post-Condition	Система починає аналіз застосунку.Таблиця 1.10 - Варіант використання UC-9Use case name	Перегляд аналітики відгуківUse case ID	UC-09Goals	Перегляд агрегованих даних аналізу відгуків користувачем.Actors	Авторизований користувач.Trigger	Користувач вставляє посилання на застосунок у форму для аналізу.Pre-conditions	Користувач авторизований в системі, дані аналізу застосунку доступні в базіFlow of Events	Система відображає на dashboard результати аналізу відгуків застосунку, а саме: загальна кількість відгуків, загальний сентимент, середня оцінка застосунку, розподіл оцінок (гістограма), розподіл сентименту (гістограма), часовий ряд сентименту (щотижнево), часовий ряд середьої оцінки застосунку та загальної кількості відгуків (щотижнево)Extension	Користувачу доступна фільтрація даних.Post-Condition	Користувач переглядає результати аналізу відгуків.Таблиця 1.11 - Варіант використання UC-10Use case name	Фільтрація результатів аналітикиUse case ID	UC-10Goals	Фільтрація результатів аналізу відгуків за заданими параметрами.Actors	Аутентифікований користувач.Trigger	Користувач встановлює параметри фільтрації.Pre-conditions	Користувач авторизований в системі, дані аналізу застосунку доступні та показані користувачу на dashboard.Flow of Events	1.	Користувач встановлює параметри фільтрації: кількість зірок, сентимент (positive, negative, neutral), платформа (AppStore or GooglePlay).2.	Система відображає на dashboard результати аналізу відгуків застосунку відфільтровані за заданими параметрами.Продовження таблиці 1.11Extension	-Post-Condition	Користувач переглядає відфільтровані результати аналізу відгуків.Таблиця 1.12 - Варіант використання UC-11Use case name	Перегляд історії пошуківUse case ID	UC-11Goals	Перегляд історії пошуків застосунків користувачем.Actors	Аутентифікований користувач.Trigger	Користувач переходить до розділу історії пошуку.Pre-conditions	-Flow of Events	Система показує користувачу список застосунків, якими нещодавно цікавився користувач. Також показано статус застосунку (updating – система оновлює дані дані застосунку, ready – дані астосунку оновлено)Extension	Користувач має можливість перехожу до аналітики кожного з нещодавних застосунків.Post-Condition	-Таблиця 1.13 - Варіант використання UC-12Use case name	Перехід до аналітики застосунку з історії пошукуUse case ID	UC-12Goals	Швидкий перехід до аналітики конкретного застосунку з історії пошуку.Actors	Аутентифікований користувач.Trigger	Користувач клікає на застосунок у своїй історії пошуку.Pre-conditions	Користувач авторизований в системі, дані аналізу застосунку доступні, користувач має не порожню історію пошуку.Flow of Events	Після кліку на застосунок система перенаправляє користувача на сторінку аналітики вибраного застосунку.Extension	-Post-Condition	Користувач перебуває на сторінці аналітики вибраного застосунку.1.4.1	Розроблення функціональних вимогПрограмне забезпечення розділене на модулі. Кожен модуль має свій певний набір функцій. Далі у таблиці 1.14 наведено загальну модель вимог, а в таблицях 1.15 – 1.42 наведений опис функціональних вимог до програмного забезпечення. Матрицю трасування вимог можна побачити у таблиці 1.43.Таблиця 1.14 – Загальна модель вимог№	Назва функціональної вимоги	ID вимоги	Пріоритет	Навантаження	Статус1	Управління користувачами	FR-1	Високий	5 story points	Draft1.1	Реєстрація користувачів	FR-2	Високий		Draft1.1.1	Пароль повинен містити щонайменше 8 символів	FR-3	Середній		Draft1.1.2	Користувач має отримати електронний лист з посиланням на підтвердження електронної пошти	FR-4	Високий		Draft1.1.2.1	У разі не підтвердження пошти, акаунт має залишатися не активним без доступу до сервісів	FR-5	Високий		Draft1.1.2.2	Токен підтвердження електронної пошти має бути вбудовано в URL-адресу підтвердження електронної пошти	FR-6	Високий		Draft1.2	Авторизація користувачів	FR-7	Високий		Draft1.3	Зміна пароля	FR-8	Середній		Draft1.3.1	Користувач повинен ввести старий пароль перед встановленням нового	FR-9	Високий		Draft1.3.2	Вимоги до нового пароля ідентичні до тих, що й при реєстрації користувача		Високий		Draft1.4	Відновлення забутого пароля	FR-10	Середній		Draft1.4.1	Система повинна надсилати посилання для відновлення пароля на електронну адресу користувача	FR-11	Високий		Draft1.4.1.1	Посилання для відновлення пароля має містити одноразовий пароль для безпеки	FR-12	Високий		Draft1.5	Вихід з системи	FR-13	Високий		Draft1.5.1	Система повинна видаляти всі сеансові дані після виходу користувача	FR-14	Низький		Draft2	Пошук застосунків	FR-15	Високий	5 story points	Draft2.1	Пошук з головної сторінки пошуку за допомогою посилання на застосунок	FR-16	Високий		Draft2.2	Історія пошуків користувача	FR-17	Низький		Draft2.2.1	Можливість швидкого переходу до аналітики застосунку з історії пошуку	FR-18	Низький		Draft3	Збір відгуків на застосунок	FR-19	Високий	10 story points	Draft3.1	Автоматичний пошук застосунку на інших платформах та збір відгуків звідти	FR-20	Високий		Draft3.2	Початковий збір усіх існуючих відгуків для нового застосунку	FR-21	Високий		Draft3.3	Періодична перевірка платформ на існування нових відгуків та їх збір	FR-22	Середній		Draft4	Аналіз сентименту відгуків	FR-23	Високий	7 story points	Draft4.1	Регулярний періодичний пошук в базі даних відгуків без даних про сентимент та їх аналіз	FR-24	Високий		Draft4.2	Відокремлення процесу аналізу відгуків від процесу збору відгуків	FR-25	Низький		Draft5	Перегляд аналітики	FR-26	Високий	10 story points	Draft5.1	Підрахунок основних статистик та часових рядів	FR-27	Високий		Draft5.2	Фільтрація аналітики	FR-28	Середній		DraftТаблиця 1.15 – Функціональна вимога FR-1Назва 	Система автентифікаціїОпис	Система повинна мати інтегровану функцію автентифікації, яка включає в себе реєстрацію, авторизацію, зміну паролю, відновлення забутого паролю та вихід з системи.Таблиця 1.16 – Функціональна вимога FR-2Назва 	Реєстрація користувачаОпис	Система повинна надавати можливість реєстрації користувачеві шляхом введення  пошти, паролю, підтвердження паролю.Таблиця 1.17 – Функціональна вимога FR-3Назва 	Мінімальна довжина пароляОпис	Пароль користувача повинен містити щонайменше 8 символів для забезпечення високого рівня безпеки.Таблиця 1.18 – Функціональна вимога FR-4Назва 	Підтвердження електронної поштиОпис	Користувач має отримати електронний лист з посиланням для підтвердження своєї електронної пошти.Таблиця 1.19 – Функціональна вимога FR-5Назва 	Статус акаунта без підтвердженняОпис	У випадку, якщо користувач не підтвердив свою електронну пошту, його акаунт повинен залишитися не активним і без доступу до сервісів.Таблиця 1.20 – Функціональна вимога FR-6Назва 	Токен підтвердження електронної поштиОпис	Токен для підтвердження електронної пошти має бути вбудований в URL-адресу посилання, що відправляється користувачеві. Це необхідно для того, аби переконатися, що пошту підтверджує саме той користувач, що щойно завершив процес реєстрації.Таблиця 1.21 – Функціональна вимога FR-7Назва 	Авторизація користувачівОпис	Система повинна надавати можливість авторизації для реєстрованих користувачів з використанням їх даних для входу (пошта та пароль).Таблиця 1.22 – Функціональна вимога FR-8Назва 	Зміна пароляОпис	Система повинна надавати можливість змінити свій пароль користувачам, які вже авторизовані в системі.Таблиця 1.23 – Функціональна вимога FR-9Назва 	Введення старого пароляОпис	При зміні пароля користувач повинен спершу ввести свій старий пароль, це додатковий рівень безпеки, щоб переконатися, що зміну пароля виконує власник акаунта.Таблиця 1.24 – Функціональна вимога FR-10Назва 	Відновлення забутого пароляОпис	Система повинна надавати користувачам можливість відновити забутий пароль, надсилаючи посилання для відновлення на електронну адресу користувача.Таблиця 1.25 – Функціональна вимога FR-11Назва 	Посилання для відновлення пароляОпис	Система повинна генерувати та надсилати посилання для відновлення пароля на електронну адресу користувача, якщо він забув свій пароль.Таблиця 1.26 – Функціональна вимога FR-12Назва 	Одноразовий пароль для безпеки відновлення пароляОпис	Посилання для відновлення пароля повинно містити одноразовий пароль для забезпечення безпеки користувача і уникнення несанкціонованого доступу до акаунта.Таблиця 1.27 – Функціональна вимога FR-13Назва 	Вихід з системиОпис	Система повинна надавати користувачам можливість вийти з свого акаунта, завершуючи поточну сеанс.Таблиця 1.28 – Функціональна вимога FR-14Назва 	Видалення сеансових данихОпис	При виході користувача, система повинна видалити всі сеансові дані, що забезпечує приватність та безпеку даних користувача (токен доступу, куки тощо)Таблиця 1.29 – Функціональна вимога FR-15Назва 	Пошук застосунківОпис	Система повинна надавати користувачам можливість здійснювати пошук застосунків, що цікавлять користувачівТаблиця 1.30 – Функціональна вимога FR-16Назва 	Пошук з головної сторінки пошуку за допомогою посилання на застосунокОпис	Система повинна дозволити користувачам здійснювати пошук застосунків прямо з головної сторінки, використовуючи посилання на застосунок.Таблиця 1.31 – Функціональна вимога FR-17Назва 	Історія пошуків користувачаОпис	Система повинна зберігати та відображати історію пошуку користувача, щоб покращити досвід користувача і прискорити процес пошуку.Таблиця 1.32 – Функціональна вимога FR-18Назва 	Швидкий перехід до аналітики застосунку з історії пошукуОпис	З історії пошуку, користувач повинен мати можливість швидкого переходу до аналітики конкретного застосунку.Таблиця 1.33 – Функціональна вимога FR-19Назва 	Збір відгуків на застосунокОпис	Система повинна здійснювати автоматичний збір відгуків на застосунок з різних платформ, щоб забезпечити всебічний огляд відгуків користувачів.Таблиця 1.34 – Функціональна вимога FR-20Назва 	Автоматичний пошук застосунку на інших платформах для збору відгуків звідтиОпис	Система повинна автоматично здійснювати пошук застосунку на різних платформах та збирати відгуки користувачів для подальшогоаналізу та забезпечення глобального огляду відгуків. Якщо користувач вводить посилання на застосунок з GooglePlay, система має перевірити, чи існує цей застосунок на AppStore і навпаки.Таблиця 1.35 – Функціональна вимога FR-21Назва 	Початковий збір усіх існуючих відгуків для нового застосункуОпис	При додаванні нового застосунку в систему, повинен бути здійснений початковий збір усіх існуючих відгуків на нього з різних платформ.Таблиця 1.36 – Функціональна вимога FR-22Назва 	Періодична перевірка платформ на існування нових відгуків та їх збірОпис	Система повинна періодично перевіряти платформи на наявність нових відгуків на застосунки та збирати ці відгуки для подальшого аналізу.Таблиця 1.37 – Функціональна вимога FR-23Назва 	Аналіз сентименту відгуківОпис	Система повинна аналізувати сентименти відгуків, отриманих з різних платформ, щоб дати користувачам узагальнений огляд відгуків на конкретний застосунок.Таблиця 1.38 – Функціональна вимога FR-24Назва 	Регулярний періодичний пошук в базі даних відгуків без даних про сентимент та їх аналізОпис	Система повинна регулярно шукати відгуки в базі даних, які ще не проаналізовані на предмет сентименту, і проводити такий аналіз, щоб забезпечити актуальність даних.Таблиця 1.39 – Функціональна вимога FR-25Назва 	Відокремлення процесу аналізу відгуків від процесу збору відгуківОпис	Система повинна відокремлювати процеси збору і аналізу відгуків, щоб оптимізувати їх виконання і забезпечити надійність в отриманні і обробці даних.Таблиця 1.40 – Функціональна вимога FR-26Назва 	Перегляд аналітикиОпис	Система повинна надавати користувачам можливість перегляду різноманітної аналітики щодо застосунків, що включає статистику, часові ряди, відгуки, сентименти тощо.Таблиця 1.41 – Функціональна вимога FR-27Назва 	Підрахунок основних статистик та часових рядівОпис	Система повинна обчислювати основні статистичні дані та часові ряди (загальна кількість відгуків, загальний сентимент, середня оцінка застосунку, розподіл оцінок (гістограма), розподіл сентименту (гістограма), часовий ряд сентименту (щотижнево), часовий ряд середьої оцінки застосунку та загальної кількості відгуків (щотижнево)) для кожного застосунку, щоб користувачам було зручно аналізувати застосунки та слідкувати за їх динамікою.Таблиця 1.42 – Функціональна вимога FR-28Назва 	Фільтрація аналітикиОпис	Система повинна надавати можливість фільтрувати аналітичні дані за різними критеріями, такими як дата, сентимент, рейтинг тощо. Це дозволить користувачам більш гнучко і точно оцінювати застосунки.Таблиця 1.43 – Матриця трасування вимог	UC-1	UC-2	UC-3	UC-4	UC-5	UC-6	UC-7	UC-8	UC-9	UC-10	UC-11	UC-12FR-1	XFR-2	XFR-3	X		XFR-4	XFR-5	XFR-6	XFR-7		XFR-8			XFR-9			XFR-10				XFR-11				XFR-12				XFR-13					XFR-14					XFR-15								X			XFR-16								X			XFR-17								X			X	XFR-18									X			XFR-19						XFR-20						XFR-21						XFR-22						XFR-23							XFR-24							XFR-25							XFR-26									X	X		XFR-27									XFR-28										X1.4.2	Розроблення нефункціональних вимог1.4.2.1 Ефективність1.4.2.1.1 Система повинна забезпечувати швидку відповідь на запити користувача, з часом відгуку не більше ніж 1 секунда (при дотриманих системних вимогах).1.4.2.1.2 Система повинна оптимально обробляти великі обсяги даних, щоб забезпечити ефективність при виконанні аналізу відгуків та аналітики застосунків.1.4.2.2 Надійність1.4.2.2.1 Система повинна бути доступною 24/7, з мінімальним часом простою не більше ніж 0.1% часу.1.4.2.2.2 Система повинна мати механізми резервного копіювання та відновлення даних, щоб забезпечити відновлюваність після можливих відмов апаратних або програмних компонентів.1.4.2.3 Безпека1.4.2.3.1 Система повинна забезпечувати конфіденційність особистої інформації користувачів (наприклад, паролів), застосовуючи шифрування даних в ході передачі та збереження згідно з GDPR (наприклад, CSRF-захист, хешування та сіль для паролів, права доступу та дозволу, захист від SQL-ін'єкцій, HTTPS і SSL);1.4.2.3.2 Система повинна мати механізми автентифікації та авторизації, щоб забезпечити доступ до функціональності тільки авторизованим користувачам.1.4.2.4 Удосконалення1.4.2.4.1 Система повинна мати можливість оновлюватися без перерви в роботі, забезпечуючи легкість встановлення оновлень та збереження конфігурацій.1.4.2.4.2 Система повинна бути масштабованою, здатною обробляти зростаючу кількість відгуків та застосунків без втрати продуктивності.1.4.2.5 Інтерфейс1.4.2.5.1 Система повинна мати інтуїтивно зрозумілий та привабливий інтерфейс користувача, забезпечуючи зручну навігацію та ергономіку.1.4.2.5.2 Система повинна бути адаптивною та сумісною з різними пристроями та розмірами екранів.1.5	Постановка задачіСуть задачі полягає в розробці програмного забезпечення для аналізу та моніторингу відгуків на мобільні застосунки. Планується створити систему, яка надасть користувачам можливість збирати, аналізувати та переглядати відгуки на різні застосунки з AppStore та GooglePlay.Розробка призначена для автоматизації та полегшення аналізу відгуків клієнтів на мобільні застосунки з метою підвищення якості обслуговування.Метою розробки є агрегація інформації про емоційне забарвлення відгуків клієнтів, що дозволяє власникам мобільних застосунків швидко та ефективно вирішувати клієнтські питання та вдосконалювати свої товари та послуги на основі зібраної інформації.Мета розробки програмного забезпечення буде досягнута за рахунок виконання наступних задач:1.	Реєстрація та авторизація користувачів: Ми надамо можливість користувачам створювати облікові записи та авторизовуватися в сервісі.2.	Збір відгуків: Сервіс буде автоматично збирати відгуки про різні застосунки з AppStore та GooglePlay для подальшого аналізу.3.	Аналіз сентименту: Ми розробимо алгоритми, які будуть аналізувати сентимент відгуків, визначаючи їх позитивність, нейтральність або негативність.4.	Перегляд аналітики відгуків: Користувачі зможуть переглядати аналітичні дані та статистику щодо відгуків на різні застосунки, такі як загальна кількість відгуків, середній сентимент, розподіл оцінок та інші метрики.5.	Управління історією пошуку: Сервіс буде зберігати історію пошуку користувачів, дозволяючи їм швидко переглядати та аналізувати застосунки, якими вони цікавилися раніше.Ці задачі визначають загальну спрямованість та функціональні можливості нашого програмного забезпечення для веб-сервісу аналізу та моніторингу відгуків на мобільні застосунки.Висновки до розділуУ даному розділі було проведено детальний аналіз предметної області аналізу та моніторингу відгуків на мобільні застосунки. Були розглянуті загальні положення, включаючи визначення мети та завдань проєкту.В рамках аналізу існуючих технологій та успішних IT-проєктів був проведений аналіз алгоритмічних та технічних рішень, допоміжних програмних засобів та засобів розробки, а також вивчення відомих програмних продуктів, зокрема за допомогою порівняльного аналізу з програмним продуктом AppFigures.Після цього було проведено докладний аналіз вимог до програмного забезпечення. Були розглянуті варіанти використання програмного забезпечення, а також показана модель вимог у загальному вигляді.Для кращого трасування вимог була побудована матриця трасування, яка відображає зв'язок між варіантами використання та функціональними вимогами.Також було проведено розроблення нефункціональних вимог, включаючи вимоги щодо безпеки, продуктивності, доступності та інших аспектів веб-сервісу.На основі проведеного аналізу була сформульована постановка задачі, яка включає в себе загальну мету проєкту та конкретні задачі, що підлягають розв'язанню у результаті розробки програмного забезпечення.Отже, у даному розділі було проведено детальне вивчення предметної області, проведений аналіз вимог, включаючи функціональні та нефункціональні вимоги, а також сформульована постановка задачі для реалізації веб-сервісу для аналізу відгуків на мобільні застосунки. 2	МОДЕЛЮВАННЯ ТА КОНСТРУЮВАННЯ ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ2.1	Моделювання та аналіз програмного забезпеченняДля опису бізнес процесу програмного забезпечення використовується BPMN модель (рисунок 2.1).Рисунок 2.1 – BPMN модель опису бізнес процесу аналізу відгуків.Опишемо процеси детальніше1.	Опис процесу реєстрації користувача: Спочатку користувач переходить на спеціальну сторінку реєстрації на веб-сайті або в додатку. Там він повинен заповнити ряд полів, що можуть включати ім'я користувача, електронну пошту, пароль та інші необхідні дані. Якщо всі введені користувачем дані відповідають встановленим вимогам (наприклад, мінімальна кількість символів в паролі), процес реєстрації продовжується, і користувач стає зареєстрованим у системі.2.	Опис процесу авторизації користувача: Після того, як користувач успішно зареєструвався, він може увійти в систему, використовуючи свої облікові дані - ім'я користувача (або електронну пошту) і пароль, які він вказав під час реєстрації. Якщо введені користувачем облікові дані вірно відповідають даним в системі, користувач отримує доступ до свого облікового запису та всіх доступних функцій системи.3.	Опис процесу пошуку застосунку за посиланням: Користувач має можливість вводити посилання на конкретний застосунок у спеціальне поле для пошуку на веб-сайті або в додатку. Після цього система проводить перевірку, чи існує вказаний застосунок за цим посиланням. Якщо застосунок дійсно існує, система автоматично виконує запит на отримання аналітичних даних про цей застосунок.4.	Опис процесу отримання аналітики: Після отримання запиту з ідентифікатором застосунку, система починає збирати і фільтрувати всю доступну інформацію про відгуки на цей застосунок, агрегує отриману статистику та повертає її користувачу, що дозволяє отримати глибоке розуміння загальної картини використання та оцінки застосунку.5.	Опис процесу відображення сторінки з аналітикою: Після отримання аналітичних даних користувачу показується спеціальна сторінка з аналітикою застосунку. На цій сторінці користувач може вибрати різні фільтри для отримання більш деталізованої аналітики, що відповідає його потребам.6.	Опис процесу створення асинхронної задачі на збір відгуків: Якщо під час перевірки посилання виявилося, що застосунок ще не представлений в базі даних системи, система автоматично створює асинхронну задачу на збір відгуків для цього застосунку. Це означає, що система почне збирати відгуки про застосунок у фоновому режимі.7.	Опис процесу аналізу сентименту відгуків: Цей процес запускається автоматично кожні 15 секунд. Система сканує базу даних на наявність відгуків, у яких ще не визначено сентимент, аналізує їх на позитивний, негативний або нейтральний сентимент, а потім оновлює дані в базі даних.8.	Опис процесу виходу з системи: Коли користувач завершує роботу з системою, він може вийти зі свого облікового запису, натиснувши кнопку "Вихід". Після цього він буде виведений з системи, а його облікові дані буде видалено з поточної сесії, що забезпечує його приватність та безпеку.2.2	Архітектура програмного забезпеченняПри проектуванні та розробці нашої системи аналізу відгуків, вирішено було використати багатошарову клієнт-серверну архітектуру. Цей вибір є основою нашого архітектурного підходу, що значно впливає на структуру та функціонування нашої системи. Для забезпечення кращого розуміння, у подальшому викладі буде описано деталізоване втілення цієї архітектури, включаючи компоненти та їх взаємодію, а також надано схеми та таблиці для наглядності.2.2.1	Архітектурний патернРисунок 2.2 – Схема архітектури веб-сервісу для аналізу відгуківОпис взаємодії компонентів на схемі.Користувач (клієнт) та фронтенд (React): Користувач взаємодіє з нашою системою через веб-інтерфейс, створений за допомогою React. За допомогою цього інтерфейсу користувач може робити запити до системи (наприклад, отримати інформацію або внести зміни).Фронтенд (React) та NGINX: Коли користувач робить запит через фронтенд, цей запит відправляється до NGINX. NGINX виконує функцію зворотного проксі-сервера, керуючи ці запити до відповідного місця в системі.NGINX та Gunicorn (WSGI-сервер): NGINX передає вхідні запити на Gunicorn, який служить як WSGI-сервер. Gunicorn обробляє ці запити, перетворюючи їх на формат, який може розуміти Python Django.Gunicorn та бекенд (Python Django): Запити, отримані Gunicorn'ом, передаються до бекенду, написаного на Django. Тут вони обробляються згідно з бізнес-логікою програми, що може включати взаємодію з базою даних.Бекенд (Python Django) та PostgreSQL: Django використовує базу даних PostgreSQL для зберігання та отримання даних. Коли до бекенду надходить запит, він може зробити запит до бази даних для отримання необхідної інформації або зберегти нові дані.Бекенд (Python Django), Celery, та Redis: Celery використовується для асинхронного виконання завдань, які могли б бути важкими або часовими для основного потоку обробки Django. Django створює завдання, які поміщаються в Redis, брокер повідомлень, а потім Celery бере ці завдання з Redis і виконує їх.Docker: Усі зазначені компоненти можуть бути упаковані в Docker-контейнери. Docker дозволяє ізолювати ці компоненти в їх власному середовищі з усіма необхідними залежностями, що забезпечує гнучкість і переносимість системи.2.2.2	Деталізація компонентівРисунок 2.3 – Діаграма ключових класів веб-сервісу аналізу відгуківУ контексті дипломної роботи, бекенд компонент має вирішальне значення для системи аналізу відгуків. Нижче наведено детальний опис кожного класу та його ключових методів, що виконують важливі функції у системі.BaseAppReviewsScraper (абстрактний клас): Цей клас є базовим класом для всіх скраперів відгуків. Він містить основні методи, такі як get_reviews, який отримує відгуки, та _parse_review_object, який парсить об'єкти відгуків. Важливі методи _perform_anti_blocking_actions та __rotate_session_user_agent виконують дії для уникнення блокування та ротації користувацьких агентів сесії.BaseReviewScrapingProcessRunner (абстрактний клас): Цей клас відповідає за виконання процесу скрапінгу відгуків для певного додатку. Він містить методи для налаштування, запуску та керування процесом скрапінгу, такі як _get_scraper, який повертає відповідний скрапер відгуків, та _logger, який забезпечує логування подій.AppStoreReviewScrapingProcessRunner та GooglePlayReviewScrapingProcessRunner: Ці класи успадковуються від BaseReviewScrapingProcessRunner і реалізують конкретний процес скрапінгу відгуків для App Store та Google Play відповідно. Вони визначають конкретний scraping_runner_class та мають власний _market.BaseAppReviewsScraper (абстрактний клас): Цей клас є базовим класом для скраперів відгуків для конкретного маркету (наприклад, App Store або Google Play). Він містить загальні методи для скрапінгу відгуків, такі як _set_reviews_endpoint_headers_and_params, _parse_review_object та _get_next_offset.AppStoreAppReviewsScraper та GooglePlayAppReviewsScraper: Ці класи успадковуються від BaseAppReviewsScraper і реалізують конкретний скрапер відгуків для App Store та Google Play відповідно. Вони визначають методи для отримання відгуків та додаткові методи для обробки та фільтрації отриманих даних.GooglePlayAllReviewScrapingDaemon та AppStoreAllReviewScrapingDaemon: Ці класи відповідають за запуск процесу скрапінгу відгуків для всіх додатків з App Store та Google Play відповідно. Вони наслідуються від BaseAllReviewScrapingDaemon і мають методи для отримання списку додатків для скрапінгу та виконання паралельних процесів скрапінгу.AnalyticsManager: Цей клас відповідає за аналіз отриманих відгуків. Він отримує DataFrame з відгуками і надає аналітичні показники, такі як загальна кількість відгуків, загальний настрій, середній рейтинг, розподіл рейтингів, розподіл настроїв, часові ряди настроїв, рейтингів та кількості відгуків. Клас має властивість для кожного показника, яка обчислює значення на основі вхідних даних.	Ці класи виконують ключові функції у системі аналізу відгуків та допомагають зрозуміти, як працює система. Бекенд компонент відповідає за скрапінг відгуків, керування процесом скрапінгу, аналіз та надання аналітичних показників. Це важливо для отримання інсайтів з великого обсягу відгуків та здатності приймати виважені рішення на основі цих даних.2.3	Конструювання програмного забезпечення2.3.1	Оригінальні реалізації2.3.1.1 Паралелізм з патерном «Стратегія»У проєкті реалізовано оригінальний підхід, який використовує патерн Стратегія для оптимальної роботи з маркетплейсами App Store і Google Play. Це доцільно, оскільки обидва маркетплейси мають схожі вимоги до скрапінгу, збереження даних та аналізу. Використання патерну Стратегія дозволяє гнучко налаштовувати алгоритми для кожного маркетплейсу і забезпечує зручний механізм заміни алгоритмів без необхідності внесення змін у вже наявний код.Далі, через незалежність процесів для App Store та Google Play, виявилося доцільним виконувати їх паралельно для прискорення роботи. Однак, мова програмування Python має глобальний блокувальний механізм GIL (Global Interpreter Lock), який обмежує паралельність виконання на рівні потоків. Це означає, що використання стандартних потоків Python не забезпечує повного використання потенціалу багатопоточності.Для цього, в проєкті було прийняте рішення використовувати модуль threading, який надає багатопоточність в межах одного процесу. Використання потоків (threads) дозволяє виконувати паралельні задачі, такі як скрапінг, збереження даних та аналіз, одночасно і прискорювати процес обробки великого обсягу даних.Підхід з використанням модуля threading у поєднанні з патерном Стратегія забезпечує ефективне та швидке виконання процесів для App Store та Google Play, дозволяючи отримати результати аналізу відгуків швидше та ефективніше.2.3.1.2 Lock на базі RedisТакож, я створив власний "замок" на базі Redis. Це досягнуто за допомогою хеш-таблиці, де ключем є lock_id, а значенням - oid. Контекстний менеджер redis_lock встановлює блокування, перевіряє його доступність та налаштовує час його спливу. Після виконання коду в блоку try, блокування автоматично звільняється у блоку finally за допомогою видалення ключа з хеш-таблиці Redis.Декоратор task_with_lock використовує цей "замок" для створення non-overlapping задач у фреймворку Celery. Це означає, що задача, означена декоратором, буде запущена тільки в тому випадку, якщо блокування було успішно отримано. Інакше, якщо інший екземпляр задачі вже запущений, новий екземпляр буде відхилений.Оригінальність полягає у використанні Redis як засобу забезпечення блокування та утримання non-overlapping задач. Це важливо, оскільки для проекту, де проводиться аналіз великого обсягу відгуків, необхідно забезпечити, щоб тільки один екземпляр задачі запускався одночасно. Це допомагає уникнути проблем, пов'язаних з одночасною обробкою одних і тих самих даних, конфліктами або некоректними результатами аналізу. Використання non-overlapping задач дозволяє забезпечити правильну та безпечну обробку великого потоку вхідних даних, що є критичним для точності та ефективності аналітичних операцій у проекті.В якості системи управління базами даних використовується Postgres. База даних серверу призначена для зберігання «відомих» застосунків та їх відгуків. Також зберігаються дані користувачів, а також їх історія пошуків застосунків. Опис таблиць бази даних наведено у таблицях 2.1 – 2.6 Модель бази даних наведена на рисунку 2.4.Таблиця 2.1 – Опис таблиці UserТаблиця	Назва поля	Тип даних	ОписUser	id	UUID	ідентифікаційний номер користувача	username	varchar	ім'я користувача	first_name	varchar	ім'я користувача	last_name	varchar	прізвище користувача	email	varchar	електронна пошта користувача	is_staff	boolean	позначка, чи є користувач працівником адміністрації	is_active	boolean	позначка, чи є користувач активним	date_joined	datetime	дата та час реєстрації користувача	searched_applications	M2M (through)	зв'язок з таблицею Application через проміжну таблицюТаблиця 2.2 – Опис таблиці EmailConfirmationTokenТаблиця	Назва поля	Тип даних	ОписEmailConfirmationToken	id	UUID	ідентифікаційний номер токена підтвердження електронної пошти	user_id	UUID	посилання на запис у таблиці User, до якого відноситься токен	token	varchar	токен підтвердження електронної пошти	expires_at	datetime	дата та час закінчення дії токена підтвердженняТаблиця 2.3 – Опис таблиці TokenТаблиця	Назва поля	Тип даних	ОписToken	key	varchar	ключ авторизаційного токена	user_id	UUID	посилання на запис у таблиці User, до якого відноситься токен	created	datetime	дата та час створення токена авторизаціїТаблиця 2.4 – Опис таблиці SearchHistoryТаблиця	Назва поля	Тип даних	ОписSearchHistory	id	UUID	ідентифікаційний номер історії пошуку	user_id	UUID	посилання на запис у таблиці User, до якого відноситься історія пошуку	application_id	UUID	посилання на запис у таблиці Application, до якого відноситься історія пошукуТаблиця 2.5 – Опис таблиці ApplicationТаблиця	Назва поля	Тип даних	ОписApplication	id	UUID	ідентифікаційний номер заявки	name	varchar	назва заявки	app_store_id	varchar	ідентифікатор заявки в AppStore	app_store_slug	varchar	слаг заявки в AppStore	app_store_status	varchar	статус заявки в AppStore	app_store_last_scraped_at	datetime	дата та час останнього скрапінгу з AppStore	google_play_id	varchar	ідентифікатор заявки в Google Play	google_play_status	varchar	статус заявки в Google Play	google_play_last_scraped_at	datetime	дата та час останнього скрапінгу з Google PlayТаблиця 2.6 – Опис таблиці ReviewТаблиця	Назва поля	Тип даних	ОписReview	id	UUID	ідентифікаційний номер відгуку	application_id	UUID	посилання на запис у таблиці Application, що відноситься до відповідного застосунку	content	text	текст відгуку	username	varchar	ім'я користувача, який залишив відгук	stars	int	кількість зірок, яку отримав застосунок від користувача	market	varchar	ринок, з якого отримано відгук (AppStore або Google Play)	source_id	varchar	ідентифікатор джерела, з якого отримано відгук	source_created_at	datetime	дата та час створення відгуку на джерелі	sentiment_str	varchar	ідентифікатор джерела, з якого отримано відгук	is_sentiment_analyzed	boolean	дата та час створення відгуку на джереліРисунок 2.4 – Фізична модель бази данихОпис утиліт, бібліотек та іншого стороннього програмного забезпечення, що використовується у розробці наведено в таблиці 2.7.Таблиця 2.7 – Опис утиліт№п/п	Назва утиліти	Опис застосування1	PyCharm	Головне середовище розробки програмного забезпечення серверної частини курсової роботи.2	Postman	Програмне забезпечення необхідне для тестування rest запитів. Використовувалось для тестування API інтерфейсів, та клієнтських запитів.3	Redis-cli	Командний інтерфейс Redis для швидкого доступу до збережених даних.4	Сelery-cli	Командний інтерфейс Celery для контролю стану черг задач.5	Django	Веб-фреймворк для розробки веб-додатків на Python. Django забезпечує швидкий і зручний спосіб створення потужних веб-додатків з підтримкою бази даних, аутентифікації, адміністративної панелі та іншими функціями, що можуть бути важливими для твоєї системи аналізу відгуків.6	aiohttp	Бібліотека для асинхронного HTTP-запиту, яка дозволяє взаємодіяти з веб-серверами у неасинхронному режимі. Вона є потужним інструментом для виконання асинхронних запитів до різних ресурсів, таких як App Store або Google Play, для отримання відгуків інших даних.7	Celery	Розподілена система завдань на основі специфікації робіт, яка дозволяє асинхронно виконувати завдання в фоновому режимі. Celery є потужним інструментом для планування та виконання задач, таких як аналіз відгуків, безпосередньо у фоновому режимі з використанням розподіленої системи черги.8	Pandas	Бібліотека для обробки та аналізу даних. pandas надає широкі можливості для маніпулювання даними, зчитування та запису даних у різних форматах, фільтрації, групування, обчислення статистики та багато іншого. Це незамінний інструмент для роботи зі структурованими даними в контексті аналізу відгуків.9	Transformers	Бібліотека transformers є потужним інструментом для роботи з моделями згорткових нейронних мереж (transformer models) у сфері обробки природної мови (NLP). Вона реалізовує відомі моделі, такі як BERT,		GPT, RoBERTa, DistilBERT та багато інших, які досягли вражаючих результатів у завданнях аналізу сентименту тексту10	React	Це потужна JavaScript бібліотека для розробки користувацького інтерфейсу. Вона дозволяє розробникам створювати ефективні та перевикористовувані компоненти, що динамічно відображаються при зміні стану даних. Завдяки віртуальному DOM та односторонньому потоку даних, React забезпечує швидку та ефективну рендеринг та оновлення інтерфейсу користувача.2.4	Аналіз безпеки данихМожливо додати про те, що надає djangoБуло проведено огляд вразливостей програмного забезпечення та розглянуто питання, пов'язані з безпекою даних.Під час розробки проекту були вжиті заходи для забезпечення безпеки даних та запобігання вразливостям. Використання фреймворку Django забезпечує вбудовані механізми безпеки, такі як захист від хакерських атак, перевірка введених даних на коректність, аутентифікація та авторизація користувачів, а також захист бази даних від несанкціонованого доступу.Були використані різні методи та технології для забезпечення безпеки даних. Наприклад, в моделі User використовується вбудований механізм аутентифікації та авторизації Django, який дозволяє безпечно зберігати паролі користувачів у хешованому форматі. Також було встановлено обмеження на унікальність поля email, що дозволяє запобігти створенню дублікатів користувачів.Крім того, використання моделей Token та EmailConfirmationToken забезпечує безпечну обробку та зберігання токенів авторизації та підтвердження електронної пошти. Це дозволяє забезпечити безпеку при реєстрації та авторизації користувачів.Також, враховуючи вимоги до безпеки даних, було встановлено обмеження на доступ до деяких ресурсів та функцій за допомогою прав доступу та ролей користувачів. Наприклад, модель Review містить поле is_sentiment_analyzed, яке позначає, чи було проведено аналіз настрою тексту відгуку. Це поле доступне тільки для внутрішнього використання і не доступне для зовнішніх запитів.До того ж, Django - це високорівневий веб-фреймворк Python, який має багато вбудованих механізмів безпеки. Ці механізми забезпечують збереження даних в безпечному стані та запобігають поширеним векторам атак. Давайте розглянемо деякі з них:Захист від SQL Injection: Django використовує ORM (Object-Relational Mapping) для взаємодії з базою даних. ORM автоматично перетворює запити до бази даних, виконані на Python, в SQL, забезпечуючи вбудований захист від SQL-ін'єкцій.Захист від XSS атак (Cross-site scripting): Django автоматично екранує символи, які мають спеціальне значення в HTML, кожного разу, коли ви використовуєте шаблонні теги. Це означає, що виходи, відтворені у вашому HTML, автоматично захищаються від певних XSS-атак.CSRF захист (Cross Site Request Forgery): Django має вбудований захист від атак CSRF. Це забезпечує, що лише форми, які дійсно походять від вашого веб-сайту, можуть бути використані для відправлення даних, тим самим запобігаючи певним типам зловмисного використання.Аутентифікація та авторизація: Django має потужну систему аутентифікації та авторизації. Вона дозволяє легко створювати облікові записи користувачів, управляти доступом користувачів до певних частин вашого веб-сайту, групувати користувачів, управляти правами користувачів і так далі.Надійне зберігання паролів: Django забезпечує надійне зберігання паролів, використовуючи "сіль", що допомагає запобігти атакам райнбоу таблиць, і "пепер", що запобігає атакам брутфорса. Паролі користувачів зберігаються в базі даних у хешованому вигляді, що робить їх непридатними для зловмисників, навіть якщо вони зможуть отримати доступ до бази даних.Clickjacking захист: Django має захист від Clickjacking шляхом надання механізму, що додає заголовок X-Frame-Options до кожного відповіді, якщо це включено у налаштуваннях.Загалом, використання належних практик безпеки даних у всіх аспектах розробки допомогло забезпечити високий рівень захисту і надійності системи, зменшити ризик вразливостей та незаконного доступу до даних, а також забезпечити конфіденційність та цілісність інформації.Висновки до розділуВ даному розділі дипломної роботи було проведено моделювання та конструювання програмного забезпечення, а також здійснено аналіз безпеки даних.У підрозділі "Моделювання та аналіз програмного забезпечення" було використано BPMN модель для опису бізнес процесу програмного забезпечення. Це дозволило детально визначити послідовність та взаємодію компонентів системи, що сприяє ясному розумінню функціональності та структури програмного забезпечення.У розділі "Архітектура програмного забезпечення" була представлена схема архітектури веб-сервісу для аналізу відгуків (рисунок 2.2). Ця схема відображає взаємодію між компонентами системи та розкриває їхні функціональні обов'язки. Це сприяє ефективній і організованій роботі системи, забезпечує легкість супроводження та масштабування.Також було проведено аналіз безпеки даних, в якому були розглянуті вразливості програмного забезпечення та питання, пов'язані з безпекою даних. Застосування належних практик безпеки, використання механізмів аутентифікації та авторизації, а також захисту від несанкціонованого доступу дозволяють забезпечити високий рівень безпеки та захисту даних у розробленій системі.В цілому, виконання роботи у даному розділі дозволило вирішити завдання, пов'язані з моделюванням, конструюванням та аналізом програмного забезпечення, а також забезпечити безпеку даних у системі. Це важливий крок у розвитку проекту та гарантує його стабільну та безпомилкову роботу. 3	АНАЛІЗ ЯКОСТІ ТА ТЕСТУВАННЯ ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ3.1	Аналіз якості ПЗ3.1.1	Аналіз відповідності нефункціональним вимогамПо-перше, проаналізуємо відповідність програмного забепечення розробленого в даній дипломній роботі заявленим нефункціональним вимогам.Система забезпечує швидку відповідь на запити користувача. Для прикладу, початковий запит на отримання аналітики по всім існуючим в базі даних відгукам для застосунку Roblox (з 2016 року) виконався з часом відгуку не більше ніж 1 секунда без попередньо закешованих результатів (рисунок 3.1). Це підтверджує знатність програмного забезпечення швидко та оптимально оброблювати великі обсяги даних за коротких проміжок часу (н.ф вимоги  1.4.2.1.1 та 1.4.2.1.2)Рисунок 3.1 – Аналіз швидкодії застосунку на прикладі запиту для застосунку Roblox.По-друге, система має механізм автентифікації та авторизації (н.ф вимога 1.4.2.3.2) для забезпечення доступу до функціональності тільки авторизованим користувачам (рисунок 3.2)Рисунок 3.2 – Наявна система автентифікації у розробленому програмному забезпеченні	По-третє, система забезпечувє конфіденційність (н.ф вимога 1.4.2.3.1) особистої інформації користувачів (наприклад, паролів) шляхом хешування (рисунок 3.3.).Рисунок 3.3 – Приклад захешованого пароляЩоб система могла оновлюватися без перерви в роботі, зусилля було зосереджено на створенні модульної архітектури Django. Кожен модуль системи був розроблений так, щоб його можна було оновлювати незалежно від інших. Це означає, що оновлення можна розгортати поетапно, без необхідності вимкнення всієї системи. Вдосконалення коду проводилися з дотриманням принципів clean code, щоб забезпечити його читабельність та легкість подальшого внесення змін. Також завдяки цьому, система може легко масштабуватися, додаванням додаткових вузлів до мережі при збільшенні обсягу завдань. Цей підхід дозволяє системі ефективно обробляти зростаючу кількість відгуків та застосунків без втрати продуктивності. Всі компоненти системи були ретельно протестовані на витривалість та продуктивність, що гарантує їх надійну роботу при масштабуванні (н.ф вимоги 1.4.2.4.1 та 1.4.2.4.2)Наостанок, система має інтуїтивно зрозумілий та привабливий інтерфейс користувача, забезпечуючи зручну навігацію та ергономіку на різних пристроях (н.ф. вимоги 1.4.2.5.1 та 1.4.2.5.2) (рисунки 3.4).Рисунок 3.4 – Приклад інтуїтивно зрозумілого інтерфейсу розробленого застосунку.	3.1.2	Метрики якості коду	3.1.2.1 Вибір метрик та аналізаторівМетрики оцінки якості програмного забезпечення відіграють важливу роль у розробці якісних програмних продуктів на мові Python. Дотримання цих метрик сприяє поліпшенню якості, зручності та безпеки програмного коду.1.	Cyclomatic Complexity (Цикломатична складність): Ця метрика вимірює складність програмного коду шляхом підрахунку кількості можливих шляхів виконання у функціях або методах. Вона дозволяє виявляти складні місця в коді, де можуть бути проблеми з розумінням, тестуванням та підтримкою. Зменшення цикломатичної складності сприяє зрозумілості та простоті коду.2.	Code Duplication (Дублювання коду): Ця метрика оцінює кількість повторюваного коду у програмному проекті. Дублювання коду може призводити до проблем утримання та розширення програми. Шляхом виявлення та усунення дублікатів коду полегшується підтримка та розвиток проекту.3.	Code Smells («Пахощі» коду): Ця метрика вказує на наявність можливих проблем або недоліків у програмному коді, які можуть призвести до складнощів у майбутньому. Наприклад, довгий метод, неправильне використання змінних чи погане форматування коду можуть бути ознаками «пахощів» коду. Виявлення та виправлення цих проблем сприяє поліпшенню читабельності та підтримки коду.4.	Security Vulnerabilities (Вразливості безпеки): Ця метрика оцінює рівень безпеки програмного коду, виявляючи потенційні вразливості, які можуть бути використані для атак. Вона дозволяє розробникам виявляти та усувати слабкі місця, забезпечуючи високий рівень безпеки програмного забезпечення.5.	Maintainability Metrics (Метрики збереженості): Ці метрики оцінюють здатність програмного коду до підтримки та розвитку. Вони включають такі аспекти, як зрозумілість, простота, документованість та легкість модифікацій. Вимірювання цих метрик допомагає забезпечити гнучкість та швидкість у внесенні змін у коді.Для аналізу відповідності цим метрикам у коді Python існують різні інструменти або аналізатори. Ось декілька відомих аналізаторів, які можуть допомогти вам у процесі аналізу коду:1.	Radon (https://radon.readthedocs.io/): Це Python-бібліотека, яка надає інструменти для обчислення різних метрик, включаючи цикломатичну складність та дублювання коду.2.	Pylint (https://pylint.org/): Цей аналізатор проводить статичний аналіз коду Python з точки зору якості, виявляючи можливі проблеми з безпекою, стилем коду та інші «пахощі».3.	Bandit (https://pypi.org/project/bandit/): Цей інструмент призначений для виявлення потенційних вразливостей безпеки у коді Python. Він пропонує аналізувати програми на наявність вразливих місць.4.	Flake8 (https://flake8.pycqa.org/): Це популярний інструмент для статичного аналізу коду Python, який комбінує перевірку стилю коду, виявлення потенційних проблем та дотримання PEP 8 (стандарту стилю коду Python). Flake8 допомагає забезпечити однорідність та зрозумілість коду, полегшуючи підтримку та співпрацю в команді.Використання цих аналізаторів допоможе вам оцінити відповідність метрикам якості та знайти можливі проблеми у вашому програмному коді на мові Python.3.1.2.2 Перевірка коду на відповідність метрикамЗа результатами виконання Flake8, отримано наступний вивід (рисунок 3.5).flake8.main.application   MainProcess    330 INFO     Found a total of 22 violations and reported 0Рисунок 3.6 – Результат роботи flake8Цей вивід повідомляє про те, що в процесі виконання Flake8 було створено необхідні перевірки (checkers) для аналізу коду. Після завершення виконання аналізу, Flake8 звітує про помилки та порушення, які були знайдені.Проте, у даному випадку вивід показує, що знайдено 22 порушення (violations), проте жодна з них не була повідомлена (reported). Це означає, що Flake8 не знайшов жодних помилок чи порушень у вашому коді.Враховуючи, що вивід вказує на відсутність помилок, можна зробити припущення, що ваш код відповідає вищезгаданим метрикам, таким як стиль коду, дотримання PEP 8, відсутність дублювання коду та інші порушення.Це позитивний результат, що свідчить про високу якість вашого програмного коду з точки зору вищезгаданих метрик. Проте, важливо пам'ятати, що відсутність помилок у звіті Flake8 не означає повну відсутність проблем у коді. Завжди рекомендується звернути увагу на дотримання найкращих практик програмування та вдосконалювати код згідно з потребами проекту.За результатами виводу Bandit, отримано такий звіт (рисунок 3.7):Рисунок 3.7 – Результат роботи banditУ процесі виконання Bandit не було виявлено жодних проблем або вразливостей у програмному коді. Звіт показує, що виконано аналіз коду, включаючи 2511 рядків коду. При цьому було пропущено 1 рядок, який містив коментар #nosec.За метриками проблем та рівнями впевненості, було виявлено нульову кількість проблем. Це означає, що незалежно від рівня серйозності або впевненості, не було виявлено жодних проблем або вразливостей у коді.Цей результат є добрим, оскільки відсутність проблем або вразливостей є позитивним показником. Це свідчить про те, що програмний код відповідає стандартам безпеки та відсутність потенційних проблем.Звіт Bandit підтверджує, що код не містить вразливостей безпеки, а отже, він відповідає вищезгаданим метрикам безпеки програмного забезпечення.Проте, варто зазначити, що цей результат є одним із багатьох інструментів та методів для оцінки безпеки програмного коду. Завжди важливо продовжувати забезпечувати безпеку шляхом використання найкращих практик програмування та регулярного аудиту та тестування коду.За результатами виводу Pylint, отримано наступний звіт (рисунок 3.8):Рисунок 3.8 – Результат роботи pylintЗа результатами аналізу, код був оцінений на рівні 9.35/10. Це є дуже високою оцінкою, що свідчить про те, що код відповідає вищезгаданим метрикам якості та стилю коду.Pylint проводить широкий аналіз програмного коду, оцінюючи його з точки зору дотримання стандарту стилю коду PEP 8 та виявлення потенційних проблем.Отримана оцінка 9.35 є дуже хорошою, що вказує на те, що код майже бездоганний і містить незначну кількість помилок чи проблем, які варто виправити. Це свідчить про високу якість та читабельність коду, а також його відповідність стандартам.Метрики, які були покриті в аналізі коду, включають вимоги стилю коду PEP 8, такі як правильне форматування, іменування змінних та функцій, використання пробілів та відступів. Крім того, аналізувалися й інші потенційні проблеми, такі як неправильне використання змінних, недостатнє документування та інші фактори, які можуть впливати на якість та читабельність коду.Отримана оцінка підтверджує високу якість вашого програмного коду, який відповідає вищезгаданим метрикам та допомагає забезпечити розробку якісного програмного забезпечення.За результатами виконання команди radon cc, отримано такий звіт (рисунок 3.9):Рисунок 3.9 – Результат роботи radonУ процесі аналізу було досліджено 195 блоків коду, які включають класи, функції та методи. Середнє значення складності коду (Average complexity) становить 1.6974358974358974, що вказує на те, що середня складність коду є дуже низькою.Це є добрим результатом, оскільки низька складність коду є показником того, що програмний код є простим та легким для розуміння та підтримки. Низька складність сприяє полегшенню розробки, тестування та виявлення помилок у програмному забезпеченні.Метрика Cyclomatic Complexity, яка оцінює складність програмного коду на основі кількості можливих шляхів виконання, була покрита в цьому випадку. Чим нижче значення середньої складності (Average complexity), тим краще, оскільки це свідчить про простоту та зрозумілість коду.Отриманий результат вказує на те, що ваш програмний код має низьку складність та відповідає метрикам якості, що сприяє його легкій підтримці та розвитку.ВисновокУ цьому підрозділі проведено аналіз відповідності розробленого програмного забезпечення нефункціональним вимогам, викладеним у постановці задачі. Було розглянуто такі вимоги, як швидкодія, механізм автентифікації та авторизації, конфіденційність, модульна архітектура, масштабованість та інтуїтивно зрозумілий інтерфейс користувача.Під час аналізу було встановлено, що розроблене програмне забезпечення успішно задовольняє вимоги швидкодії, забезпечуючи швидку відповідь на запити користувача. Тестування показало, що навіть при обробці великого обсягу даних, час відгуку не перевищує 1 секунди.Також було підтверджено наявність механізму автентифікації та авторизації, що дозволяє обмежувати доступ до функціональності системи лише авторизованим користувачам.У контексті конфіденційності особистої інформації користувачів, було використано метод хешування паролів, що забезпечує збереження конфіденційності інформації.Модульна архітектура системи була ретельно розроблена з урахуванням принципів clean code, що дозволяє оновлювати різні компоненти системи незалежно один від одного та забезпечує легкість підтримки та масштабування системи.Оцінка коду на відповідність метрикам якості була проведена за допомогою статичного аналізу та використанням різних код-аналізаторів. За допомогою інструментів, таких як Pylint, Flake8, Bandit та Radon CC, було підтверджено відповідність коду встановленим метрикам. Результати аналізу показали, що розроблений код має високу якість та відповідає вимогам стилю коду, безпеки та складності.Загалом, результати аналізу вказують на те, що розроблене програмне забезпечення відповідає встановленим нефункціональним вимогам. Швидкодія, механізм автентифікації та авторизації, конфіденційність, модульна архітектура та інтуїтивно зрозумілий інтерфейс користувача були успішно реалізовані. Додатково, аналіз метрик якості коду підтвердив високу якість та відповідність розробленого коду встановленим стандартам.В цілому, отримані результати підтверджують успішне виконання нефункціональних вимог та гарантують якість розробленого програмного забезпечення. Дані висновки будуть використані в подальшому розділі для детальнішого опису функціональних вимог та розробки програмного продукту.3.2	Опис процесів тестуванняПроцес розробки програмного забезпечення включає багато етапів, одним з найважливіших з яких є тестування. Це допомагає забезпечити стабільність, функціональність та безпеку програмного забезпечення. Для нашого застосунку ми використовуємо підхід, відомий як піраміда тестування, який містить три рівні: модульне (unit) тестування, інтеграційне тестування та системне тестування.З усіх цих рівнів, мануальне тестування займає особливе місце в нашому процесі, зокрема через його важливість для забезпечення якості нашого продукту.Мануальне тестування - це процес перевірки програмного забезпечення вручну з метою виявлення помилок і проблем, що виникають під час його використання. Воно включає перевірку функціональності, зручності використання, стабільності, а також різних сценаріїв використання, що випливають з вимог до продукту.Мануальне тестування є незамінним для нашого застосунку з декількох причин:1.	Сценарії використання: Ми розробляємо додаток для аналізу та моніторингу відгуків на мобільні застосунки. Це означає, що ми маємо багато різних сценаріїв використання, які ми маємо врахувати, та які можуть бути складно перевірити автоматично.2.	Взаємодія з користувачем: Наша система має багато взаємодій з користувачами, що включає реєстрацію, авторизацію, перегляд аналітики відгуків і управління історією пошуку. Ці процеси мають бути простими, зручними та безпечними для користувача, і мануальне тестування допомагає нам це забезпечити.3.	Функціональність: Ми хочемо впевнитись, що кожна функція нашого додатку працює належним чином. Мануальне тестування дозволяє нам перевірити це на практиці, використовуючи реальні сценарії використання.Таким чином, хоча ми використовуємо інші методики тестування, мануальне тестування є важливою частиною нашого процесу забезпечення якості.Було виконане мануальне тестування програмного забезпечення, опис відповідних тестів наведено у таблицях 3.1 – 3.16.Таблиця 3.1 – Тест 1.1Тест 	Реєстрація користувачаМодуль	Реєстрація користувачаНомер тесту 	1.1Початковий стан системи 	Користувач знаходиться на сторінці реєстраціїВхідні данні 	Електронна пошта, пароль, підтвердження паролюОпис проведення тесту 	У відповідні поля вводяться: коректна електронна пошта, яка до цього не була зареєстрована в системі, пароль, який складається з 8 символів, і підтвердження паролю, яке співпадає з раніше введеним паролем. Після цього натискається кнопка підтвердження реєстрації.Очікуваний результат	Реєстрація проходить успішно, користувач додається у систему і отримує на свою електронну адресу лист з підтвердженням.Фактичний результат	Реєстрація проходить успішно, користувач додається у систему і отримує на свою електронну адресу лист з підтвердженням.Таблиця 3.2 – Тест 1.2Тест 	Підтвердження електронної поштиМодуль	Реєстрація користувачаНомер тесту 	1.2Початковий стан системи 	Користувач успішно зареєстрований і отримав електронний лист з посиланням на підтвердження електронної поштиВхідні данні 	Посилання на підтвердження електронної поштиОпис проведення тесту 	Користувач натискає на посилання для підтвердження електронної пошти, яке він отримав на свою електронну адресу.Очікуваний результат	Користувач успішно підтвердив свою електронну пошту, статус його акаунта в системі змінюється на активний.Фактичний результат	Користувач успішно підтвердив свою електронну пошту, статус його акаунта в системі змінюється на активний.Таблиця 3.3 – Тест 1.3Тест 	Статус акаунта без підтвердженняМодуль	Авторизація користувачаНомер тесту 	1.3Початковий стан системи 	Користувач зареєстрований, але не підтвердив свою електронну поштуВхідні данні 	Електронна пошта, парольОпис проведення тесту 	Користувач намагається увійти до системи, використовуючи свою електронну пошту та пароль.Очікуваний результат	Користувач не може увійти до системи, оскільки його акаунт ще не активовано.Фактичний результат	Користувач не може увійти до системи, оскільки його акаунт ще не активовано.Таблиця 3.4 – Тест 1.4Тест 	Авторизація користувачаМодуль	Авторизація користувачаНомер тесту 	1.4Початковий стан системи 	Користувач підтвердив свою електронну пошту і має активний статус акаунтаВхідні данні 	Електронна пошта, парольОпис проведення тесту 	Користувач вводить свою електронну пошту та пароль для авторизації в системі.Очікуваний результат	Користувач успішно авторизується і має доступ до сервісів.Фактичний результат	Користувач успішно авторизується і має доступ до сервісів.Таблиця 3.5 – Тест 1.5Тест 	Зміна пароляМодуль	Управління акаунтомНомер тесту 	1.5Початковий стан системи 	Користувач авторизований в системіВхідні данні 	Старий пароль, новий пароль, підтвердження нового пароляОпис проведення тесту 	Користувач вводить свій старий пароль, потім новий пароль і підтвердження нового пароля. Після цього він натискає кнопку зміни пароля. Новий пароль має відповідати тим же вимогам, що і при реєстрації.Очікуваний результат	Пароль користувача успішно змінено.Фактичний результат	Пароль користувача успішно змінено.Таблиця 3.6 – Тест 1.6Тест 	Введення невірного старого пароляМодуль	Управління акаунтомНомер тесту 	1.6Початковий стан системи 	Користувач авторизований в системіВхідні данні 	Старий пароль, новий пароль, підтвердження нового пароляОпис проведення тесту 	Користувач вводить невірний старий пароль, потім новий пароль і підтвердження нового пароля. Після цього він натискає кнопку зміни пароля.Очікуваний результат	Повідомлення про помилку, яке повідомляє, що введено невірний старий пароль.Фактичний результат	Повідомлення про помилку, яке повідомляє, що введено невірний старий пароль.Таблиця 3.7 – Тест 1.7Тест 	Невірне підтвердження нового пароляМодуль	Управління акаунтомНомер тесту 	1.7Початковий стан системи 	Користувач авторизований в системіВхідні данні 	Старий пароль, новий пароль, підтвердження нового пароляОпис проведення тесту 	Користувач вводить свій старий пароль, потім новий пароль і невірне підтвердження нового пароля. Після цього він натискає кнопку зміни пароля.Очікуваний результат	Повідомлення про помилку, яке повідомляє, що підтвердження нового пароля не співпадає з новим паролем.Фактичний результат	Повідомлення про помилку, яке повідомляє, що підтвердження нового пароля не співпадає з новим паролем.Таблиця 3.8 – Тест 1.8Тест 	Невдала спроба відновлення паролю з неправильною електронною поштоюМодуль	Відновлення паролюНомер тесту 	1.8Початковий стан системи 	Користувач на сторінці відновлення паролюВхідні данні 	Електронна поштаОпис проведення тесту 	Користувач вводить електронну пошту, яка не зареєстрована в системі, а потім натискає кнопку відновлення паролю.Очікуваний результат	Повідомлення про помилку, яке повідомляє, що такої електронної адреси немає в системі.Фактичний результат	Повідомлення про помилку, яке повідомляє, що такої електронної адреси немає в системі.Таблиця 3.9 – Тест 1.9Тест 	Успішне відновлення паролюМодуль	Відновлення паролюНомер тесту 	1.9Початковий стан системи 	Користувач на сторінці відновлення паролюВхідні данні 	Електронна поштаОпис проведення тесту 	Користувач вводить свою зареєстровану електронну адресу, а потім натискає кнопку відновлення паролю.Очікуваний результат	Користувач отримує електронний лист з посиланням на сторінку зміни паролю.Фактичний результат	Написати після виконання тестуТаблиця 3.10 – Тест 1.10Тест 	Перевірка дієздатності посилання зміни паролюМодуль	Відновлення паролюНомер тесту 	1.10Початковий стан системи 	Користувач отримав електронний лист з посиланням на зміну паролюВхідні данні 	Посилання на зміну паролюОпис проведення тесту 	Користувач переходить за посиланням для зміни паролю не пізніше ніж через 5 хвилин після отримання посиланняОчікуваний результат	Користувач перенаправляється на сторінку, де може ввести новий пароль.Фактичний результат	Користувач перенаправляється на сторінку, де може ввести новий пароль.Таблиця 3.11 – Тест 1.11Тест 	Зміна паролю з використанням посилання для відновленняМодуль	Відновлення паролюНомер тесту 	1.11Початковий стан системи 	Користувач перейшов за посиланням для зміни паролюВхідні данні 	Новий парольОпис проведення тесту 	Користувач вводить новий пароль, підтверджує його, а потім натискає кнопку для зміни паролю. Новий пароль має відповідати тим же вимогам, що і при реєстрації.Очікуваний результат	Пароль успішно змінено, користувач перенаправляється на сторінку авторизації.Фактичний результат	Пароль успішно змінено, користувач перенаправляється на сторінку авторизації.Таблиця 3.12 – Тест 1.12Тест 	Авторизація зі зміненим паролемМодуль	АвторизаціяНомер тесту 	1.12Початковий стан системи 	Користувач на сторінці авторизаціїВхідні данні 	Електронна пошта, новий парольОпис проведення тесту 	Користувач вводить свою електронну пошту та новий пароль, потім натискає кнопку входу.Очікуваний результат	Користувач успішно авторизовується та перенаправляється на головну сторінку.Фактичний результат	Користувач успішно авторизовується та перенаправляється на головну сторінку.Таблиця 3.13 – Тест 1.13Тест 	Авторизація зі старим паролем після його зміниМодуль	АвторизаціяНомер тесту 	1.13Початковий стан системи 	Користувач на сторінці авторизаціїВхідні данні 	Електронна пошта, старий парольОпис проведення тесту 	Користувач вводить свою електронну пошту та старий пароль, потім натискає кнопку входу.Очікуваний результат	Користувачу відмовлено в доступі з повідомленням про невірний пароль.Фактичний результат	Користувачу відмовлено в доступі з повідомленням про невірний пароль.Таблиця 3.14 – Тест 1.14Тест 	Відновлення забутого паролю з некоректною електронною адресоюМодуль	Відновлення паролюНомер тесту 	1.14Початковий стан системи 	Користувач на сторінці відновлення паролюВхідні данні 	Некоректна електронна адресаОпис проведення тесту 	Користувач вводить некоректну електронну адресу (що не відповідає регулярному виразу, що використовується для валідації пошти, наприклад, у пошті пропущений символ @), потім натискає кнопку відновлення паролю.Очікуваний результат	Користувачу відмовлено в відновленні паролю з повідомленням про помилку в електронній адресі.Фактичний результат	Користувачу відмовлено в відновленні паролю з повідомленням про помилку в електронній адресі.Таблиця 3.15 – Тест 1.15Тест 	Вихід з системиМодуль	ВихідНомер тесту 	1.15Початковий стан системи 	Користувач авторизований у системі та перебуває на головній сторінціВхідні данні 	НемаєОпис проведення тесту 	Користувач натискає кнопку виходу з системи.Очікуваний результат	Користувач успішно вийшов з системи та перенаправлений на сторінку авторизації.Фактичний результат	Користувач успішно вийшов з системи та перенаправлений на сторінку авторизації.Таблиця 3.16 – Тест 1.16Тест 	Пошук застосунків з головної сторінкиМодуль	Пошуковий модульНомер тесту 	2.1Початковий стан системи 	Авторизований користувач на головній сторінціВхідні данні 	Посилання на застосунокОпис проведення тесту 	Користувач вставляє посилання на застосунок у поле пошуку та натискає на кнопку "Пошук".Очікуваний результат	Застосунок знайдено, інформація про нього відображається на екрані.Фактичний результат	Застосунок знайдено, інформація про нього відображається на екрані.Таблиця 3.17 – Тест 1.17Тест 	Перегляд історії пошуків користувачаМодуль	Пошуковий модульНомер тесту 	2.2Початковий стан системи 	Користувач зареєстрований та авторизованийВхідні данні 	НемаєОпис проведення тесту 	Користувач переходить на сторінку історії пошуків.Очікуваний результат	Історія пошуків користувача відображається на екрані.Фактичний результат	Історія пошуків користувача відображається на екрані.Таблиця 3.18 – Тест 1.18Тест 	Збір відгуків на застосунокМодуль	Модуль збору відгуківНомер тесту 	3.1Початковий стан системи 	Застосунок знайдено та він відображається на екраніВхідні данні 	НемаєОпис проведення тесту 	Програмне забезпечення автоматично збирає відгуки на цей застосунок з різних платформ.Очікуваний результат	Всі доступні відгуки зібрані та їх аналітика відображаються користувачу.Фактичний результат	Всі доступні відгуки зібрані та їх аналітика відображаються користувачу.Таблиця 3.19 – Тест 1.19Тест 	Перегляд аналітикиМодуль	Модуль аналітикиНомер тесту 	5.2Початковий стан системи 	Користувач перебуває на сторінці аналітики застосункуВхідні данні 	НемаєОпис проведення тесту 	Користувач встановлює певні критерії фільтрації для аналітики застосунку та натискає кнопку "Фільтрувати".Очікуваний результат	Аналітика застосунку відображається з урахуванням заданих критеріїв фільтрації.Фактичний результат	Аналітика застосунку відображається з урахуванням заданих критеріїв фільтрації.Таблиця 3.19 – Тест 1.19Тест 	Фільтрація аналітикиМодуль	Модуль аналітикиНомер тесту 	5.2Початковий стан системи 	Користувач перебуває на сторінці аналітики застосункуВхідні данні 	Критерії фільтрації (наприклад, дата, тип відгуку, оцінка тощо)Опис проведення тесту 	Користувач встановлює певні критерії фільтрації для аналітики застосунку та натискає кнопку "Фільтрувати".Очікуваний результат	Аналітика застосунку відображається з урахуванням заданих критеріїв фільтрації.Фактичний результат	Аналітика застосунку відображається з урахуванням заданих критеріїв фільтрації.3.3	Опис контрольного прикладуРобота з сервісом починається з реєстрації нового акаунту користувача. Сторінка реєстрації показана на рисунку …Форма реєстрації захищена валідацією (рисунок …)У разі успішного підтвердження форми користувач отримує повідомлення з проханням перевірити пошту для підтвердження електронної адреси.Лист містить посилання для підтвердження поштиПісля переходу за посиланням користувач бачить повідомлення про те, що пошту підтверджено та сервіс прохає користувача авторизуватися.Форма авторизації також захищена валідацією. При введенні неправильних пошти та пароля система повідомляє користувачу, що авторизація пройшла неуспішно.Після успішної авторизації користувач бачить головну сторінку пошуку застосунків.Для пошуку застосунку користувач вставляє посилання на застосунок у пошукове полеЯкщо аналітики для шуканого застосунку ще немає в базі даних, то сервіс повідомлює користувача про це.З часом на сторінці можна побачити аналітику відгуків застосункуУ вкладці “History” можна побачити історію пошуку користувача.Історія дозволяє швидку навігацію до сторінки за аналітикою застосунку шляхом натискання на кнопку посилання.Аналітику дозволено фільтрувати. Ось, наприклад, аналітика відфільтрована на показ даних лише для відгуків з оцінкою від 3 до 5.Авторизованому користувачу дозволено змінити парольЗміна пароля проводиться шляхом вводу старого та нового паролівВихід з системи проводиться шляхом натискання на кнопку Logout у профілі користувачаВисновки до розділуУ третьому розділі було вдатно здійснено аналіз якості програмного забезпечення та детально описано процеси тестування, які були застосовані до розробленої системи. При цьому особлива увага була приділена відповідності системи нефункціональним вимогам, включаючи параметри швидкодії, механізми автентифікації та авторизації, забезпечення конфіденційності, а також принципи модульної архітектури та інтуїтивно зрозумілого інтерфейсу користувача.У розділі також було проведено обгрунтований вибір метрик та аналізаторів для перевірки коду на відповідність метрикам. Застосування інструментів статичного аналізу коду, таких як Pylint, Flake8, Bandit та Radon CC, дозволило оцінити якість коду, його безпеку, стиль та складність. Результати цього аналізу свідчать про високий рівень якості коду, що було написано в рамках даного проекту.Окремої уваги в розділі заслуговує опис процесів тестування, де було подано інформацію про тестувальні сценарії, типи тестів, що використовувалися, та результати тестування. Використання систематичного підходу до тестування дозволило переконатися в надійності і стабільності розробленого програмного забезпечення.Також було наведено опис контрольного прикладу використання програми, що дозволило демонструвати практичну реалізацію функціональності системи в реальних умовах використання.В цілому, на підставі результатів, що були отримані в ході реалізації третього розділу, можна зробити висновок про те, що розроблене програмне забезпечення відповідає встановленим нефункціональним вимогам, має високий рівень якості коду та прошло необхідні процедури тестування. Дані результати є важливою підставою для подальшого розроблення програмного продукту та його впровадження в практичну діяльність.4	ВПРОВАДЖЕННЯ ТА СУПРОВІД ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ4.1	Розгортання програмного забезпечення<У підрозділі викладають:повний опис покрокового розгортання ПЗ. Кроки доповнюють ілюстраціями.>Клієнтську і серверну частини програмного забезпечення було вирішено розгорнути на платформі Heroku. Для розгортання було використано сервіс GitHub Actions, який надає можливості для постійної інтеграції і розгортання [13].Розгортання починається коли новий код застосунку доставляється у репозиторій у гілку main. Тоді у середовищі GitHub Actions створюється Docker image за допомогою Dockerfile, що знаходиться у проекті. Цей image розгортається у Heroku за допомогою пакету heroku-deploy. Інформацію про розгортання клієнтської і серверної частини проекту можна побачити на рисунках 4.1 і 4.2.Рисунок 4.1 - Інформація про розгортання клієнтуДля розгортання клієнтської та серверної частини програмного забезпечення використовується Docker Compose та платформа Linode. Docker Compose - це інструмент для опису та запуску багатоконтейнерних Docker-додатків. За допомогою Docker Compose можна використовувати YAML-файли для конфігурації служб вашого застосунку. Потім за допомогою єдиного командного рядка можна створити і запустити всі служби з вашої конфігурації.Рисунок 4.1 – Налаштований Docker-composeЗастосунок розгортається на Ubuntu сервері, арендованому на платформі Linode.Рисунок 4.1 – Linode Ubuntu серверРозгортання застосунку, а також нової його версії відбувається за допомогою shell скрипта, який робить pull гілки master з репозиторіїв фронтенду та бекенду (рисунок 4.1),Рисунок 4.1 – Оновлення репозиторіїв з master гілокзупиняє поточну версію застосунку за допомогою команди `docker-compose down` та викликає команду `docker-compose up –build`, що будує нові images та запускає на них контейнери.Рисунок 4.1 – Нові запущені контейнери застосунку4.2	Підтримка програмного забезпечення<У підрозділі викладають:опис того, як буде виконуватись підтримка програмного забезпечення. Ілюстрації.>Підтримка програмного забезпечення включає в себе регулярне оновлення коду, слідкування за стабільністю роботи та вирішення можливих проблем та збоїв. Автоматизація цих процесів здійснюється за допомогою Docker Compose та shell скрипта, що запускає команди docker-compose down та docker-compose up --build.Коли в гілці master відбувається зміна необхідно запустити з сервера скрипт автоматично зупиняє поточну версію застосунку, робить pull оновленого коду і запускає нову версію. Таким чином, користувач завжди може мати доступ до останньої стабільної версії застосунку.Щоб демонструвати підтримку програмного забезпечення, вам можна показати скріншоти консольних виводів оновлення застосунку, а також виведення логів, які демонструють стабільну роботу застосунку.Висновки до розділуУ даному розділі було виконано розгортання та супровід програмного забезпечення. Для цього було використано Docker Compose та платформу Linode. Docker Compose дозволив описати та запустити багатоконтейнерні Docker-додатки за допомогою YAML-файлів. Цей процес забезпечує стабільність та легкість управління службами застосунку.Серверна частина програмного забезпечення була розгорнута на сервері Ubuntu, який арендується на платформі Linode. Розгортання, а також оновлення програмного забезпечення, здійснювалось автоматично за допомогою shell скрипта. Цей скрипт виконує pull гілки master з репозиторіїв фронтенду та бекенду, зупиняє поточну версію застосунку та запускає нову версію за допомогою команд Docker Compose.Що стосується підтримки програмного забезпечення, вона включала регулярне оновлення коду, слідкування за стабільністю роботи та вирішення можливих проблем та збоїв. Автоматизація процесу підтримки була досягнута за допомогою Docker Compose та shell скрипта, який виконує перебудову та перезапуск служб застосунку при зміні гілки master.Таким чином, було забезпечено стабільне функціонування та оновлення програмного забезпечення, а також підтримку останніх версій компонентів застосунку. Даний підхід до розгортання та підтримки програмного забезпечення виявився ефективним та практичним, забезпечуючи високий рівень стабільності та продуктивності системи.ВИСНОВКИУ висновках викладають найважливіші наукові й практичні результати роботи та наводять:	оцінку одержаних результатів і їх відповідність сучасному рівню наукових і технічних знань;	ступінь впровадження та можливі галузі або сфери використання результатів роботи;	наукову, науково-технічну, соціально-економічну значущість роботи;	доцільність продовження досліджень за відповідною тематикою тощо.Також у висновках необхідно відобразити стан вирішення усіх поставлених в дипломному проєктуванні задач.В результаті виконання дипломного проєкту було спроєктовано …В якості середовища розробки обрано …У якості БД використано …Після реалізації застосунку він був протестований на пристроях з різними версіями Android, з різними розмірами екранів щоб переконатися, що додаток акуратно відображається на різних пристроях.Наукова новизна роботи (якщо вона є) полягає в наступному (достатньо вказати щось одне).Вперше:	реалізовано можливість запитів від пацієнта до лікаря;	використано те-то, що дозволило те-то.Модифіковано:	те-то, що дозволило те-то.Набуло подальший розвиток:	те-то, що дозволило те-то. СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ1)	Liu, B. Sentiment analysis and opinion mining / B. Liu // Synthesis lectures on human language technologies. - 2012. - №5(1). - С. 1-167.2)	Pang, B., Lee, L. Opinion mining and sentiment analysis / B. Pang, L. Lee // Foundations and Trends® in Information Retrieval. - 2008. - №2(1–2). - С. 1-135.3)	Cambria, E., et al. SenticNet 6: Ensemble application of symbolic and subsymbolic AI for sentiment analysis / E. Cambria, et al. // Proceedings of the 29th ACM International Conference on Information & Knowledge Management. - 2020.4)	Kucher, K., Kerren, A. The state of the art in sentiment visualization / K. Kucher, A. Kerren // Computer Graphics Forum. - 2018. - Vol. 38. - №1.5)	Martín-Valdivia, M.T., Martínez-Cámara, E., Ureña-López, L.A. Sentiment analysis in Twitter / M.T. Martín-Valdivia, E. Martínez-Cámara, L.A. Ureña-López // Natural language engineering. - 2014. - №20(1). - С. 1-28.6)	Chen, H., et al. Business intelligence and analytics: From big data to big impact / H. Chen, et al. // MIS quarterly. - 2012. - №36(4). - С. 1165-1188.7)	Erkan, G., Radev, D. R. (2004). LexRank: Graph-based Lexical Centrality as Salience in Text Summarization. Journal of Artificial Intelligence Research, 22, 457-479.8)	Liu, B. (2012). Sentiment Analysis and Opinion Mining. Synthesis Lectures on Human Language Technologies, 5(1), 1-167.9)	Pang, B., Lee, L. (2008). Opinion mining and sentiment analysis. Foundations and Trends in Information Retrieval, 2(1–2), 1-135.10)	А. Метьюс. Алгоритми машинного навчання для початківців: наївний Баєсівський класифікатор. 2022.11)	Devlin, J., Chang, M. W., Lee, K., & Toutanova, K. BERT: Pre-training of deep bidirectional transformers for language understanding. arXiv preprint arXiv:1810.04805, 2018.12)	Bird, Steven, Edward Loper and Ewan Klein (2009), Natural Language Processing with Python. O’Reilly Media Inc. ДОДАТКИ